// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

window.BabelFish = (function (modules) {
	var getModule, getRequire, require;
	getModule = (function (wrap) {
		return function (scope, tree, path, fullpath) {
			var name, dir, exports, module, fn, isDir;
			path = path.split('/');
			name = path.pop();
			if (!name) {
				isDir = true;
				name = path.pop();
			}
			if ((name === '.') || (name === '..')) {
				path.push(name);
				name = '';
			}
			while ((dir = path.shift())) {
				if (dir === '..') {
					scope = tree.pop();
				} else if (dir !== '.') {
					tree.push(scope);
					scope = scope[dir];
					if (!scope) {
						throw new Error("Could not find module '" + fullpath + "'");
					}
				}
			}
			if (name) {
				if (!isDir && scope[name + '.js']) {
					name += '.js';
				}
				if (typeof scope[name] === 'object') {
					tree.push(scope);
					scope = scope[name];
					name = 'index.js';
				}
			} else {
				name = 'index.js';
			}
			fn = scope[name];
			if (!fn) throw new Error("Could not find module '" + fullpath + "'");
			if (fn.hasOwnProperty('module')) return fn.module.exports;
			exports = {};
			fn.module = module = { exports: exports };
			fn.call(exports, exports, module, getRequire(scope, tree));
			return module.exports;
		};
	}(function (cmodule) {
		return function (ignore, module) {
			module.exports = cmodule.exports;
		};
	}));
	require = function (scope, tree, fullpath) {
		var name, path = fullpath, t = fullpath.charAt(0);
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name];
			tree = [];
			path = path.slice(name.length + 1) || scope[':mainpath:'];
		}
		return getModule(scope, tree, path, fullpath);
	};
	getRequire = function (scope, tree) {
		return function (path) {
			return require(scope, [].concat(tree), path);
		};
	};
	return getRequire(modules, []);
})({
	"babelfish": {
		"lib": {
			"babelfish": {
				"parser.js": function (exports, module, require) {
					module.exports = (function(){
					  /*
					   * Generated by PEG.js 0.7.0.
					   *
					   * http://pegjs.majda.cz/
					   */
					  
					  function quote(s) {
					    /*
					     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
					     * string literal except for the closing quote character, backslash,
					     * carriage return, line separator, paragraph separator, and line feed.
					     * Any character may appear in the form of an escape sequence.
					     *
					     * For portability, we also escape escape all control and non-ASCII
					     * characters. Note that "\0" and "\v" escape sequences are not used
					     * because JSHint does not like the first and IE the second.
					     */
					     return '"' + s
					      .replace(/\\/g, '\\\\')  // backslash
					      .replace(/"/g, '\\"')    // closing quote character
					      .replace(/\x08/g, '\\b') // backspace
					      .replace(/\t/g, '\\t')   // horizontal tab
					      .replace(/\n/g, '\\n')   // line feed
					      .replace(/\f/g, '\\f')   // form feed
					      .replace(/\r/g, '\\r')   // carriage return
					      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
					      + '"';
					  }
					  
					  var result = {
					    /*
					     * Parses the input with a generated parser. If the parsing is successfull,
					     * returns a value explicitly or implicitly specified by the grammar from
					     * which the parser was generated (see |PEG.buildParser|). If the parsing is
					     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
					     */
					    parse: function(input, startRule) {
					      var parseFunctions = {
					        "start": parse_start,
					        "plural": parse_plural,
					        "plural_forms": parse_plural_forms,
					        "plural_part": parse_plural_part,
					        "plural_char": parse_plural_char,
					        "plural_anchor": parse_plural_anchor,
					        "variable": parse_variable,
					        "identifier": parse_identifier,
					        "identifier_part": parse_identifier_part,
					        "literal": parse_literal,
					        "literal_char": parse_literal_char
					      };
					      
					      if (startRule !== undefined) {
					        if (parseFunctions[startRule] === undefined) {
					          throw new Error("Invalid rule name: " + quote(startRule) + ".");
					        }
					      } else {
					        startRule = "start";
					      }
					      
					      var pos = 0;
					      var reportFailures = 0;
					      var rightmostFailuresPos = 0;
					      var rightmostFailuresExpected = [];
					      
					      function padLeft(input, padding, length) {
					        var result = input;
					        
					        var padLength = length - input.length;
					        for (var i = 0; i < padLength; i++) {
					          result = padding + result;
					        }
					        
					        return result;
					      }
					      
					      function escape(ch) {
					        var charCode = ch.charCodeAt(0);
					        var escapeChar;
					        var length;
					        
					        if (charCode <= 0xFF) {
					          escapeChar = 'x';
					          length = 2;
					        } else {
					          escapeChar = 'u';
					          length = 4;
					        }
					        
					        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
					      }
					      
					      function matchFailed(failure) {
					        if (pos < rightmostFailuresPos) {
					          return;
					        }
					        
					        if (pos > rightmostFailuresPos) {
					          rightmostFailuresPos = pos;
					          rightmostFailuresExpected = [];
					        }
					        
					        rightmostFailuresExpected.push(failure);
					      }
					      
					      function parse_start() {
					        var result0, result1;
					        
					        result0 = [];
					        result1 = parse_plural();
					        if (result1 === null) {
					          result1 = parse_variable();
					          if (result1 === null) {
					            result1 = parse_literal();
					          }
					        }
					        while (result1 !== null) {
					          result0.push(result1);
					          result1 = parse_plural();
					          if (result1 === null) {
					            result1 = parse_variable();
					            if (result1 === null) {
					              result1 = parse_literal();
					            }
					          }
					        }
					        return result0;
					      }
					      
					      function parse_plural() {
					        var result0, result1, result2, result3;
					        var pos0, pos1;
					        
					        pos0 = pos;
					        pos1 = pos;
					        if (input.substr(pos, 2) === "((") {
					          result0 = "((";
					          pos += 2;
					        } else {
					          result0 = null;
					          if (reportFailures === 0) {
					            matchFailed("\"((\"");
					          }
					        }
					        if (result0 !== null) {
					          result1 = parse_plural_forms();
					          if (result1 !== null) {
					            if (input.substr(pos, 2) === "))") {
					              result2 = "))";
					              pos += 2;
					            } else {
					              result2 = null;
					              if (reportFailures === 0) {
					                matchFailed("\"))\"");
					              }
					            }
					            if (result2 !== null) {
					              result3 = parse_plural_anchor();
					              result3 = result3 !== null ? result3 : "";
					              if (result3 !== null) {
					                result0 = [result0, result1, result2, result3];
					              } else {
					                result0 = null;
					                pos = pos1;
					              }
					            } else {
					              result0 = null;
					              pos = pos1;
					            }
					          } else {
					            result0 = null;
					            pos = pos1;
					          }
					        } else {
					          result0 = null;
					          pos = pos1;
					        }
					        if (result0 !== null) {
					          result0 = (function(offset, forms, anchor) {
					              return {
					                type:   'plural',
					                forms:  forms,
					                anchor: anchor || 'count'
					              };
					            })(pos0, result0[1], result0[3]);
					        }
					        if (result0 === null) {
					          pos = pos0;
					        }
					        return result0;
					      }
					      
					      function parse_plural_forms() {
					        var result0, result1, result2;
					        var pos0, pos1;
					        
					        pos0 = pos;
					        pos1 = pos;
					        result0 = parse_plural_part();
					        if (result0 !== null) {
					          if (input.charCodeAt(pos) === 124) {
					            result1 = "|";
					            pos++;
					          } else {
					            result1 = null;
					            if (reportFailures === 0) {
					              matchFailed("\"|\"");
					            }
					          }
					          if (result1 !== null) {
					            result2 = parse_plural_forms();
					            if (result2 !== null) {
					              result0 = [result0, result1, result2];
					            } else {
					              result0 = null;
					              pos = pos1;
					            }
					          } else {
					            result0 = null;
					            pos = pos1;
					          }
					        } else {
					          result0 = null;
					          pos = pos1;
					        }
					        if (result0 !== null) {
					          result0 = (function(offset, part, more) {
					              return [part].concat(more);
					            })(pos0, result0[0], result0[2]);
					        }
					        if (result0 === null) {
					          pos = pos0;
					        }
					        if (result0 === null) {
					          pos0 = pos;
					          result0 = parse_plural_part();
					          if (result0 !== null) {
					            result0 = (function(offset, part) {
					                return [part];
					              })(pos0, result0);
					          }
					          if (result0 === null) {
					            pos = pos0;
					          }
					        }
					        return result0;
					      }
					      
					      function parse_plural_part() {
					        var result0, result1;
					        var pos0;
					        
					        pos0 = pos;
					        result1 = parse_plural_char();
					        if (result1 !== null) {
					          result0 = [];
					          while (result1 !== null) {
					            result0.push(result1);
					            result1 = parse_plural_char();
					          }
					        } else {
					          result0 = null;
					        }
					        if (result0 !== null) {
					          result0 = (function(offset, chars) {
					              return chars.join('');
					            })(pos0, result0);
					        }
					        if (result0 === null) {
					          pos = pos0;
					        }
					        return result0;
					      }
					      
					      function parse_plural_char() {
					        var result0, result1;
					        var pos0, pos1;
					        
					        pos0 = pos;
					        pos1 = pos;
					        if (input.charCodeAt(pos) === 32) {
					          result0 = " ";
					          pos++;
					        } else {
					          result0 = null;
					          if (reportFailures === 0) {
					            matchFailed("\" \"");
					          }
					        }
					        if (result0 !== null) {
					          result1 = parse_plural_char();
					          if (result1 !== null) {
					            result0 = [result0, result1];
					          } else {
					            result0 = null;
					            pos = pos1;
					          }
					        } else {
					          result0 = null;
					          pos = pos1;
					        }
					        if (result0 !== null) {
					          result0 = (function(offset, char) { return " " + char; })(pos0, result0[1]);
					        }
					        if (result0 === null) {
					          pos = pos0;
					        }
					        if (result0 === null) {
					          pos0 = pos;
					          pos1 = pos;
					          if (input.charCodeAt(pos) === 92) {
					            result0 = "\\";
					            pos++;
					          } else {
					            result0 = null;
					            if (reportFailures === 0) {
					              matchFailed("\"\\\\\"");
					            }
					          }
					          if (result0 !== null) {
					            if (/^[\\|)(]/.test(input.charAt(pos))) {
					              result1 = input.charAt(pos);
					              pos++;
					            } else {
					              result1 = null;
					              if (reportFailures === 0) {
					                matchFailed("[\\\\|)(]");
					              }
					            }
					            if (result1 !== null) {
					              result0 = [result0, result1];
					            } else {
					              result0 = null;
					              pos = pos1;
					            }
					          } else {
					            result0 = null;
					            pos = pos1;
					          }
					          if (result0 !== null) {
					            result0 = (function(offset, char) { return String(char); })(pos0, result0[1]);
					          }
					          if (result0 === null) {
					            pos = pos0;
					          }
					          if (result0 === null) {
					            if (/^[^ \\|)]/.test(input.charAt(pos))) {
					              result0 = input.charAt(pos);
					              pos++;
					            } else {
					              result0 = null;
					              if (reportFailures === 0) {
					                matchFailed("[^ \\\\|)]");
					              }
					            }
					          }
					        }
					        return result0;
					      }
					      
					      function parse_plural_anchor() {
					        var result0, result1;
					        var pos0, pos1;
					        
					        pos0 = pos;
					        pos1 = pos;
					        if (input.charCodeAt(pos) === 58) {
					          result0 = ":";
					          pos++;
					        } else {
					          result0 = null;
					          if (reportFailures === 0) {
					            matchFailed("\":\"");
					          }
					        }
					        if (result0 !== null) {
					          result1 = parse_identifier();
					          if (result1 !== null) {
					            result0 = [result0, result1];
					          } else {
					            result0 = null;
					            pos = pos1;
					          }
					        } else {
					          result0 = null;
					          pos = pos1;
					        }
					        if (result0 !== null) {
					          result0 = (function(offset, name) {
					              return name;
					            })(pos0, result0[1]);
					        }
					        if (result0 === null) {
					          pos = pos0;
					        }
					        return result0;
					      }
					      
					      function parse_variable() {
					        var result0, result1, result2;
					        var pos0, pos1;
					        
					        pos0 = pos;
					        pos1 = pos;
					        if (input.substr(pos, 2) === "#{") {
					          result0 = "#{";
					          pos += 2;
					        } else {
					          result0 = null;
					          if (reportFailures === 0) {
					            matchFailed("\"#{\"");
					          }
					        }
					        if (result0 !== null) {
					          result1 = parse_identifier();
					          if (result1 !== null) {
					            if (input.charCodeAt(pos) === 125) {
					              result2 = "}";
					              pos++;
					            } else {
					              result2 = null;
					              if (reportFailures === 0) {
					                matchFailed("\"}\"");
					              }
					            }
					            if (result2 !== null) {
					              result0 = [result0, result1, result2];
					            } else {
					              result0 = null;
					              pos = pos1;
					            }
					          } else {
					            result0 = null;
					            pos = pos1;
					          }
					        } else {
					          result0 = null;
					          pos = pos1;
					        }
					        if (result0 !== null) {
					          result0 = (function(offset, anchor) {
					              return {
					                type:   'variable',
					                anchor: anchor
					              };
					            })(pos0, result0[1]);
					        }
					        if (result0 === null) {
					          pos = pos0;
					        }
					        return result0;
					      }
					      
					      function parse_identifier() {
					        var result0, result1, result2, result3;
					        var pos0, pos1;
					        
					        pos0 = pos;
					        pos1 = pos;
					        result0 = parse_identifier_part();
					        if (result0 !== null) {
					          if (input.charCodeAt(pos) === 46) {
					            result1 = ".";
					            pos++;
					          } else {
					            result1 = null;
					            if (reportFailures === 0) {
					              matchFailed("\".\"");
					            }
					          }
					          if (result1 !== null) {
					            result3 = parse_identifier();
					            if (result3 !== null) {
					              result2 = [];
					              while (result3 !== null) {
					                result2.push(result3);
					                result3 = parse_identifier();
					              }
					            } else {
					              result2 = null;
					            }
					            if (result2 !== null) {
					              result0 = [result0, result1, result2];
					            } else {
					              result0 = null;
					              pos = pos1;
					            }
					          } else {
					            result0 = null;
					            pos = pos1;
					          }
					        } else {
					          result0 = null;
					          pos = pos1;
					        }
					        if (result0 !== null) {
					          result0 = (function(offset, a, b) {
					              return a + "." + b;
					            })(pos0, result0[0], result0[2]);
					        }
					        if (result0 === null) {
					          pos = pos0;
					        }
					        if (result0 === null) {
					          result0 = parse_identifier_part();
					        }
					        return result0;
					      }
					      
					      function parse_identifier_part() {
					        var result0, result1, result2;
					        var pos0, pos1;
					        
					        pos0 = pos;
					        pos1 = pos;
					        if (/^[a-zA-Z_$]/.test(input.charAt(pos))) {
					          result0 = input.charAt(pos);
					          pos++;
					        } else {
					          result0 = null;
					          if (reportFailures === 0) {
					            matchFailed("[a-zA-Z_$]");
					          }
					        }
					        if (result0 !== null) {
					          result1 = [];
					          if (/^[a-zA-Z0-9_$]/.test(input.charAt(pos))) {
					            result2 = input.charAt(pos);
					            pos++;
					          } else {
					            result2 = null;
					            if (reportFailures === 0) {
					              matchFailed("[a-zA-Z0-9_$]");
					            }
					          }
					          while (result2 !== null) {
					            result1.push(result2);
					            if (/^[a-zA-Z0-9_$]/.test(input.charAt(pos))) {
					              result2 = input.charAt(pos);
					              pos++;
					            } else {
					              result2 = null;
					              if (reportFailures === 0) {
					                matchFailed("[a-zA-Z0-9_$]");
					              }
					            }
					          }
					          if (result1 !== null) {
					            result0 = [result0, result1];
					          } else {
					            result0 = null;
					            pos = pos1;
					          }
					        } else {
					          result0 = null;
					          pos = pos1;
					        }
					        if (result0 !== null) {
					          result0 = (function(offset, a, b) {
					              return a + b.join("");
					            })(pos0, result0[0], result0[1]);
					        }
					        if (result0 === null) {
					          pos = pos0;
					        }
					        return result0;
					      }
					      
					      function parse_literal() {
					        var result0;
					        var pos0;
					        
					        pos0 = pos;
					        result0 = parse_literal_char();
					        if (result0 !== null) {
					          result0 = (function(offset, char) {
					              return {
					                type: 'literal',
					                text: String(char)
					              };
					            })(pos0, result0);
					        }
					        if (result0 === null) {
					          pos = pos0;
					        }
					        return result0;
					      }
					      
					      function parse_literal_char() {
					        var result0, result1;
					        var pos0, pos1;
					        
					        pos0 = pos;
					        pos1 = pos;
					        if (input.charCodeAt(pos) === 92) {
					          result0 = "\\";
					          pos++;
					        } else {
					          result0 = null;
					          if (reportFailures === 0) {
					            matchFailed("\"\\\\\"");
					          }
					        }
					        if (result0 !== null) {
					          if (/^[\\(#]/.test(input.charAt(pos))) {
					            result1 = input.charAt(pos);
					            pos++;
					          } else {
					            result1 = null;
					            if (reportFailures === 0) {
					              matchFailed("[\\\\(#]");
					            }
					          }
					          if (result1 !== null) {
					            result0 = [result0, result1];
					          } else {
					            result0 = null;
					            pos = pos1;
					          }
					        } else {
					          result0 = null;
					          pos = pos1;
					        }
					        if (result0 !== null) {
					          result0 = (function(offset, char) {
					              return String(char);
					            })(pos0, result0[1]);
					        }
					        if (result0 === null) {
					          pos = pos0;
					        }
					        if (result0 === null) {
					          if (input.length > pos) {
					            result0 = input.charAt(pos);
					            pos++;
					          } else {
					            result0 = null;
					            if (reportFailures === 0) {
					              matchFailed("any character");
					            }
					          }
					        }
					        return result0;
					      }
					      
					      
					      function cleanupExpected(expected) {
					        expected.sort();
					        
					        var lastExpected = null;
					        var cleanExpected = [];
					        for (var i = 0; i < expected.length; i++) {
					          if (expected[i] !== lastExpected) {
					            cleanExpected.push(expected[i]);
					            lastExpected = expected[i];
					          }
					        }
					        return cleanExpected;
					      }
					      
					      function computeErrorPosition() {
					        /*
					         * The first idea was to use |String.split| to break the input up to the
					         * error position along newlines and derive the line and column from
					         * there. However IE's |split| implementation is so broken that it was
					         * enough to prevent it.
					         */
					        
					        var line = 1;
					        var column = 1;
					        var seenCR = false;
					        
					        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
					          var ch = input.charAt(i);
					          if (ch === "\n") {
					            if (!seenCR) { line++; }
					            column = 1;
					            seenCR = false;
					          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
					            line++;
					            column = 1;
					            seenCR = true;
					          } else {
					            column++;
					            seenCR = false;
					          }
					        }
					        
					        return { line: line, column: column };
					      }
					      
					      
					      var result = parseFunctions[startRule]();
					      
					      /*
					       * The parser is now in one of the following three states:
					       *
					       * 1. The parser successfully parsed the whole input.
					       *
					       *    - |result !== null|
					       *    - |pos === input.length|
					       *    - |rightmostFailuresExpected| may or may not contain something
					       *
					       * 2. The parser successfully parsed only a part of the input.
					       *
					       *    - |result !== null|
					       *    - |pos < input.length|
					       *    - |rightmostFailuresExpected| may or may not contain something
					       *
					       * 3. The parser did not successfully parse any part of the input.
					       *
					       *   - |result === null|
					       *   - |pos === 0|
					       *   - |rightmostFailuresExpected| contains at least one failure
					       *
					       * All code following this comment (including called functions) must
					       * handle these states.
					       */
					      if (result === null || pos !== input.length) {
					        var offset = Math.max(pos, rightmostFailuresPos);
					        var found = offset < input.length ? input.charAt(offset) : null;
					        var errorPosition = computeErrorPosition();
					        
					        throw new this.SyntaxError(
					          cleanupExpected(rightmostFailuresExpected),
					          found,
					          offset,
					          errorPosition.line,
					          errorPosition.column
					        );
					      }
					      
					      return result;
					    },
					    
					    /* Returns the parser source code. */
					    toSource: function() { return this._source; }
					  };
					  
					  /* Thrown when a parser encounters a syntax error. */
					  
					  result.SyntaxError = function(expected, found, offset, line, column) {
					    function buildMessage(expected, found) {
					      var expectedHumanized, foundHumanized;
					      
					      switch (expected.length) {
					        case 0:
					          expectedHumanized = "end of input";
					          break;
					        case 1:
					          expectedHumanized = expected[0];
					          break;
					        default:
					          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
					            + " or "
					            + expected[expected.length - 1];
					      }
					      
					      foundHumanized = found ? quote(found) : "end of input";
					      
					      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
					    }
					    
					    this.name = "SyntaxError";
					    this.expected = expected;
					    this.found = found;
					    this.message = buildMessage(expected, found);
					    this.offset = offset;
					    this.line = line;
					    this.column = column;
					  };
					  
					  result.SyntaxError.prototype = Error.prototype;
					  
					  return result;
					})();
				},
				"pluralizer.js": function (exports, module, require) {
					//
					// See rules here:
					// http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
					//

					'use strict';


					// pluralizers cache
					var PLURALIZERS = {};


					module.exports = function pluralize(lang, count, forms) {
					  var idx;

					  if (!PLURALIZERS[lang]) {
					    return '[pluralizer for (' + lang + ') not exists]';
					  }

					  idx = PLURALIZERS[lang](count);

					  if (undefined === forms[idx]) {
					    return '[plural form N' + idx + ' not found in translation]';
					  }

					  return forms[idx];
					};


					// HELPERS
					////////////////////////////////////////////////////////////////////////////////


					// adds given `rule` pluralizer for given `locales` into `storage`
					function add(locales, rule) {
					  var i;
					  for (i = 0; i < locales.length; i += 1) {
					    PLURALIZERS[locales[i]] = rule;
					  }
					}

					// check if number is int or float
					function is_int(input) {
					  return (0 === input % 1);
					}

					// PLURALIZATION RULES
					////////////////////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////////////////////


					// Azerbaijani, Bambara, Burmese, Chinese, Dzongkha, Georgian, Hungarian, Igbo,
					// Indonesian, Japanese, Javanese, Kabuverdianu, Kannada, Khmer, Korean,
					// Koyraboro Senni, Lao, Makonde, Malay, Persian, Root, Sakha, Sango,
					// Sichuan Yi, Thai, Tibetan, Tonga, Turkish, Vietnamese, Wolof, Yoruba

					add(['az', 'bm', 'my', 'zh', 'dz', 'ka', 'hu', 'ig',
					  'id', 'ja', 'jv', 'kea', 'kn', 'km', 'ko',
					  'ses', 'lo', 'kde', 'ms', 'fa', 'root', 'sah', 'sg',
					  'ii',  'th', 'bo', 'to', 'tr', 'vi', 'wo', 'yo'], function () {
					  return 0;
					});


					// Manx

					add(['gv'], function (n) {
					  var m10 = n % 10, m20 = n % 20;

					  if ((m10 === 1 || m10 === 2 || m20 === 0) && is_int(n)) {
					    return 0;
					  }

					  return 1;
					});


					// Central Morocco Tamazight

					add(['tzm'], function (n) {
					  if (n === 0 || n === 1 || (11 <= n && n <= 99 && is_int(n))) {
					    return 0;
					  }

					  return 1;
					});


					// Macedonian

					add(['mk'], function (n) {
					  if ((n % 10 === 1) && (n !== 11) && is_int(n)) {
					    return 0;
					  }

					  return 1;
					});


					// Akan, Amharic, Bihari, Filipino, Gun, Hindi,
					// Lingala, Malagasy, Northern Sotho, Tagalog, Tigrinya, Walloon

					add(['ak', 'am', 'bh', 'fil', 'guw', 'hi',
					  'ln', 'mg', 'nso', 'tl', 'ti', 'wa'], function (n) {
					  return (n === 0 || n === 1) ? 0 : 1;
					});


					// Afrikaans, Albanian, Basque, Bemba, Bengali, Bodo, Bulgarian, Catalan,
					// Cherokee, Chiga, Danish, Divehi, Dutch, English, Esperanto, Estonian, Ewe,
					// Faroese, Finnish, Friulian, Galician, Ganda, German, Greek, Gujarati, Hausa,
					// Hawaiian, Hebrew, Icelandic, Italian, Kalaallisut, Kazakh, Kurdish,
					// Luxembourgish, Malayalam, Marathi, Masai, Mongolian, Nahuatl, Nepali,
					// Norwegian, Norwegian Bokmål, Norwegian Nynorsk, Nyankole, Oriya, Oromo,
					// Papiamento, Pashto, Portuguese, Punjabi, Romansh, Saho, Samburu, Soga,
					// Somali, Spanish, Swahili, Swedish, Swiss German, Syriac, Tamil, Telugu,
					// Turkmen, Urdu, Walser, Western Frisian, Zulu

					add(['af', 'sq', 'eu', 'bem', 'bn', 'brx', 'bg', 'ca',
					  'chr', 'cgg', 'da', 'dv', 'nl', 'en', 'eo', 'et', 'ee',
					  'fo', 'fi', 'fur', 'gl', 'lg', 'de', 'el', 'gu', 'ha',
					  'haw', 'he', 'is', 'it', 'kl', 'kk', 'ku',
					  'lb', 'ml', 'mr', 'mas', 'mn', 'nah', 'ne',
					  'no', 'nb', 'nn', 'nyn', 'or', 'om',
					  'pap', 'ps', 'pt', 'pa', 'rm', 'ssy', 'saq', 'xog',
					  'so', 'es', 'sw', 'sv', 'gsw', 'syr', 'ta', 'te',
					  'tk', 'ur', 'wae', 'fy', 'zu'], function (n) {
					  return (1 === n) ? 0 : 1;
					});


					// Latvian

					add(['lv'], function (n) {
					  if (n === 0) {
					    return 0;
					  }

					  if ((n % 10 === 1) && (n % 100 !== 11) && is_int(n)) {
					    return 1;
					  }

					  return 2;
					});


					// Colognian

					add(['ksh'], function (n) {
					  return (n === 0) ? 0 : ((n === 1) ? 1 : 2);
					});


					// Cornish, Inari Sami, Inuktitut, Irish, Lule Sami, Northern Sami,
					// Sami Language, Skolt Sami, Southern Sami

					add(['kw', 'smn', 'iu', 'ga', 'smj', 'se',
					  'smi', 'sms', 'sma'], function (n) {
					  return (n === 1) ? 0 : ((n === 2) ? 1 : 2);
					});


					// Belarusian, Bosnian, Croatian, Russian, Serbian, Serbo-Croatian, Ukrainian

					add(['be', 'bs', 'hr', 'ru', 'sr', 'sh', 'uk'], function (n) {
					  var m10 = n % 10, m100 = n % 100;

					  if (!is_int(n)) {
					    return 3;
					  }

					  // one → n mod 10 is 1 and n mod 100 is not 11;
					  if (1 === m10 && 11 !== m100) {
					    return 0;
					  }

					  // few → n mod 10 in 2..4 and n mod 100 not in 12..14;
					  if (2 <= m10 && m10 <= 4 && !(12 <= m100 && m100 <= 14)) {
					    return 1;
					  }

					  // many → n mod 10 is 0 or n mod 10 in 5..9 or n mod 100 in 11..14;
					/*  if (0 === m10 || (5 <= m10 && m10 <= 9) || (11 <= m100 && m100 <= 14)) {
					    return 2;
					  }

					  // other
					  return 3;*/
					  return 2;
					});


					// Polish

					add(['pl'], function (n) {
					  var m10 = n % 10, m100 = n % 100;

					  if (!is_int(n)) {
					    return 3;
					  }

					  // one → n is 1;
					  if (n === 1) {
					    return 0;
					  }

					  // few → n mod 10 in 2..4 and n mod 100 not in 12..14;
					  if (2 <= m10 && m10 <= 4 && !(12 <= m100 && m100 <= 14)) {
					    return 1;
					  }

					  // many → n is not 1 and n mod 10 in 0..1 or
					  // n mod 10 in 5..9 or n mod 100 in 12..14
					  // (all other except partials)
					  return 2;
					});


					// Lithuanian

					add(['lt'], function (n) {
					  var m10 = n % 10, m100 = n % 100;

					  if (!is_int(n)) {
					    return 2;
					  }

					  // one → n mod 10 is 1 and n mod 100 not in 11..19
					  if (m10 === 1 && !(11 <= m100 && m100 <= 19)) {
					    return 0;
					  }

					  // few → n mod 10 in 2..9 and n mod 100 not in 11..19
					  if (2 <= m10 && m10 <= 9 && !(11 <= m100 && m100 <= 19)) {
					    return 1;
					  }

					  // other
					  return 2;
					});


					// Tachelhit

					add(['shi'], function (n) {
					  return (0 <= n && n <= 1) ? 0 : ((is_int(n) && 2 <= n && n <= 10) ? 1 : 2);
					});


					// Moldavian, Romanian

					add(['mo', 'ro'], function (n) {
					  var m100 = n % 100;

					  if (!is_int(n)) {
					    return 2;
					  }

					  // one → n is 1
					  if (n === 1) {
					    return 0;
					  }

					  // few → n is 0 OR n is not 1 AND n mod 100 in 1..19
					  if (n === 0 || (1 <= m100 && m100 <= 19)) {
					    return 1;
					  }

					  // other
					  return 2;
					});


					// Czech, Slovak

					add(['cs', 'sk'], function (n) {
					  // one → n is 1
					  if (n === 1) {
					    return 0;
					  }

					  // few → n in 2..4
					  if (n === 2 || n === 3 || n === 4) {
					    return 1;
					  }

					  // other
					  return 2;
					});



					// Slovenian

					add(['sl'], function (n) {
					  var m100 = n % 100;

					  if (!is_int(n)) {
					    return 3;
					  }

					  // one → n mod 100 is 1
					  if (m100 === 1) {
					    return 0;
					  }

					  // one → n mod 100 is 2
					  if (m100 === 2) {
					    return 1;
					  }

					  // one → n mod 100 in 3..4
					  if (m100 === 3 || m100 === 4) {
					    return 2;
					  }

					  // other
					  return 3;
					});


					// Maltese

					add(['mt'], function (n) {
					  var m100 = n % 100;

					  if (!is_int(n)) {
					    return 3;
					  }

					  // one → n is 1
					  if (n === 1) {
					    return 0;
					  }

					  // few → n is 0 or n mod 100 in 2..10
					  if (n === 0 || (2 <= m100 && m100 <= 10)) {
					    return 1;
					  }

					  // many → n mod 100 in 11..19
					  if (11 <= m100 && m100 <= 19) {
					    return 2;
					  }

					  // other
					  return 3;
					});


					// Arabic

					add(['ar'], function (n) {
					  var m100 = n % 100;

					  if (!is_int(n)) {
					    return 5;
					  }

					  if (n === 0) {
					    return 0;
					  }
					  if (n === 1) {
					    return 1;
					  }
					  if (n === 2) {
					    return 2;
					  }

					  // few → n mod 100 in 3..10
					  if (3 <= m100 && m100 <= 10) {
					    return 3;
					  }

					  // many → n mod 100 in 11..99
					  if (11 <= m100 && m100 <= 99) {
					    return 4;
					  }

					  // other
					  return 5;
					});


					// Breton, Welsh

					add(['br', 'cy'], function (n) {

					  if (n === 0) {
					    return 0;
					  }
					  if (n === 1) {
					    return 1;
					  }
					  if (n === 2) {
					    return 2;
					  }
					  if (n === 3) {
					    return 3;
					  }
					  if (n === 6) {
					    return 4;
					  }

					  return 5;
					});


					// FRACTIONAL PARTS - SPECIAL CASES
					////////////////////////////////////////////////////////////////////////////////


					// French, Fulah, Kabyle

					add(['fr', 'ff', 'kab'], function (n) {
					  return (0 <= n && n < 2) ? 0 : 1;
					});


					// Langi

					add(['lag'], function (n) {
					  return (n === 0) ? 0 : ((0 < n && n < 2) ? 1 : 2);
					});

				}
			},
			"babelfish.js": function (exports, module, require) {
				/**
				 *  class BabelFish
				 *
				 *  Internalization and localization library that makes i18n and l10n fun again.
				 *
				 *  ##### Example
				 *
				 *      var BabelFish = require('babelfish'),
				 *          i18n = new BabelFish();
				 **/


				'use strict';


				var Parser = require('./babelfish/parser');
				var Pluralizer = require('./babelfish/pluralizer');


				////////////////////////////////////////////////////////////////////////////////
				// The following two utilities (forEach and extend) are modified from Underscore
				//
				// http://underscorejs.org
				//
				// (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
				//
				// Underscore may be freely distributed under the MIT license
				////////////////////////////////////////////////////////////////////////////////


				var nativeForEach = Array.prototype.forEach;


				// The cornerstone, an `each` implementation, aka `forEach`.
				// Handles objects with the built-in `forEach`, arrays, and raw objects.
				// Delegates to **ECMAScript 5**'s native `forEach` if available.
				function forEach(obj, iterator, context) {
				  if (obj === null) {
				    return;
				  }
				  if (nativeForEach && obj.forEach === nativeForEach) {
				    obj.forEach(iterator, context);
				  } else if (obj.length === +obj.length) {
				    for (var i = 0, l = obj.length; i < l; i += 1) {
				      iterator.call(context, obj[i], i, obj);
				    }
				  } else {
				    for (var key in obj) {
				      if (Object.prototype.hasOwnProperty.call(obj, key)) {
				        iterator.call(context, obj[key], key, obj);
				      }
				    }
				  }
				}


				// Extend a given object with all the properties in passed-in object(s).
				function extend(obj) {
				  forEach(Array.prototype.slice.call(arguments, 1), function(source) {
				    if (source) {
				      for (var prop in source) {
				        obj[prop] = source[prop];
				      }
				    }
				  });
				  return obj;
				}


				// helpers
				////////////////////////////////////////////////////////////////////////////////


				// Last resort locale, that exists for sure
				var GENERIC_LOCALE = 'en';


				//  flattenParams(obj) -> Object
				//
				//  Flattens object into one-level distionary.
				//
				//  ##### Example
				//
				//      var obj = {
				//        abc: { def: 'foo' },
				//        hij: 'bar'
				//      };
				//
				//      flattenParams(obj);
				//      // -> { 'abc.def': 'foo', 'hij': 'bar' };
				function flattenParams(obj) {
				  var params = {};

				  forEach(obj || {}, function (val, key) {
				    if (val && 'object' === typeof val) {
				      forEach(flattenParams(val), function (sub_val, sub_key) {
				        params[key + '.' + sub_key] = sub_val;
				      });
				      return;
				    }

				    params[key] = val;
				  });

				  return params;
				}


				// Merge several continuous `literal` nodes together
				function redistribute(ast) {
				  var nodes = [], last = {};

				  forEach(ast, function (node) {
				    if ('literal' === last.type && 'literal' === node.type) {
				      last.text += node.text;
				      return;
				    }

				    nodes.push(node);
				    last = node;
				  });

				  return nodes;
				}


				// Compiles given string into translator function. Used to compile phrases,
				// which contains `plurals`, `variables`, etc.
				function compile(str, locale) {
				  var nodes = redistribute(Parser.parse(str)),
				      lang  = locale.split('-').shift(),
				      translator;

				  if (1 === nodes.length && 'literal' === nodes[0].type) {
				    return nodes[0].text;
				  }

				  translator = ["var str = '';"];
				  translator.push("params = this.flattenParams(params);");

				  forEach(nodes, function (node) {
				    var anchor = "params['" + node.anchor + "']";

				    if ('literal' === node.type) {
				      translator.push("str += " + JSON.stringify(node.text) + ";");
				      return;
				    }

				    if ('variable' === node.type) {
				      translator.push(
				        "str += ( 'undefined' === typeof (" + anchor + ") )" +
				        " ? '[missed variable: " + node.anchor + "]'" +
				        " : String(" + anchor + ");"
				      );
				      return;
				    }

				    if ('plural' === node.type) {
				      translator.push(
				        "str += ( +(" + anchor + ") != (" + anchor + ") )" +
				        " ? ('[invalid plurals amount: " + node.anchor + "(' + String(" + anchor + ") + ')]')" +
				        " : this.pluralize('" + lang + "', +" + anchor + ", " + JSON.stringify(node.forms) + ");"
				      );
				      return;
				    }

				    // should never happen
				    throw new Error('Unknown node type');
				  });

				  translator.push("return str;");

				  /*jslint evil:true*/
				  return new Function('params', translator.join('\n'));
				}


				// Returns locale storage. Creates one if needed
				function getLocaleStorage(self, locale) {
				  if (undefined === self._storage[locale]) {
				    self._storage[locale] = {};
				  }

				  return self._storage[locale];
				}


				function mergeTranslations(receiver, transmitter, locale) {
				  forEach(transmitter, function (data, key) {
				    // propose translation. make a copy
				    if (data.locale === locale) {
				      receiver[key] = extend({}, data);
				    }
				  });

				  return receiver;
				}


				// recompiles phrases for locale
				function recompile(self, locale) {
				  var fallbacks, fb_locale, old_storage, new_storage;

				  fallbacks = (self._fallbacks[locale] || []).slice();
				  old_storage = getLocaleStorage(self, locale);
				  new_storage = mergeTranslations({}, getLocaleStorage(self, self.defaultLocale), self.defaultLocale);

				  // mix-in fallbacks
				  while (fallbacks.length) {
				    fb_locale = fallbacks.pop();
				    mergeTranslations(new_storage, getLocaleStorage(self, fb_locale), fb_locale);
				  }

				  // mix-in locale overrides
				  self._storage[locale] = mergeTranslations(new_storage, old_storage, locale);
				}


				// public api (module)
				////////////////////////////////////////////////////////////////////////////////


				/**
				 *  new BabelFish([defaultLocale = 'en'])
				 *
				 *  Initiates new instance of BabelFish. It can't be used as function (without
				 *  `new` keyword. Use [[BabelFish.create]] for this purpose.
				 **/
				function BabelFish(defaultLocale) {
				  /** read-only
				   *  BabelFish#defaultLocale -> String
				   *
				   *  Default locale, tht will be used if requested locale has no translation,
				   *  and have no fallacks or none of its fallbacks have translation as well.
				   **/
				  Object.defineProperty(this, 'defaultLocale', {
				    value: defaultLocale && String(defaultLocale) || GENERIC_LOCALE
				  });

				  // hash of locale => [ fallback1, fallback2, ... ] pairs
				  this._fallbacks = {};

				  // hash of fallback => [ locale1, locale2, ... ] pairs
				  this._fallbacksReverse = {};

				  // states of compilation per each locale locale => bool pairs
				  this._compiled = {};

				  // storage of compiled translations
				  this._storage = {};
				}


				/** chainable
				 *  BabelFish.create([defaultLocale = 'en']) -> BabelFish
				 *
				 *  Syntax sugar for constructor:
				 *
				 *      new BabelFish('ru')
				 *      // equals to:
				 *      BabelFish.create('ru');
				 **/
				BabelFish.create = function create(defaultLocale) {
				  return new BabelFish(defaultLocale);
				};


				// public api (instance)
				////////////////////////////////////////////////////////////////////////////////


				/** chainable
				 *  BabelFish#addPhrase(locale, phrase, translation) -> BabelFish
				 *  - locale (String): Locale of translation
				 *  - phrase (String|Null): Phrase ID, e.g. `apps.forum`
				 *  - translation (String|Object): Translation or an object with nested phrases.
				 *
				 *  ##### Errors
				 *
				 *  - **TypeError** when `translation` is neither _String_ nor _Object_.
				 *
				 *  ##### Example
				 *
				 *      i18n.addPhrase('ru-RU',
				 *        'apps.forums.replies_count',
				 *        '#{count} %{ответ|ответа|ответов}:count в теме');
				 *
				 *      // equals to:
				 *      i18n.addPhrase('ru-RU',
				 *        'apps.forums',
				 *        { replies_count: '#{count} %{ответ|ответа|ответов}:count в теме' });
				 **/
				BabelFish.prototype.addPhrase = function addPhrase(locale, phrase, translation) {
				  var self = this, t = typeof translation;

				  if ('string' !== t && 'object' !== t && translation !== (translation || '').toString()) {
				    throw new TypeError('Invalid translation. String or Object expected');
				  } else if ('object' === t) {
				    // recursive recursion
				    forEach(translation, function (val, key) {
				      self.addPhrase(locale, phrase + '.' + key, val);
				    });
				    return;
				  }

				  // compile phrase
				  translation = compile(translation, locale);

				  getLocaleStorage(this, locale)[phrase] = {
				    type:         ('function' === typeof translation) ? 'function' : 'string',
				    locale:       locale,
				    translation:  translation
				  };

				  // mark all "dependant" locales for recompilation
				  forEach(self._fallbacksReverse[locale] || [], function (locale) {
				    // we need to recompile non-default locales only
				    if (locale !== self.defaultLocale) {
				      self._compiled[locale] = false;
				    }
				  });

				  return this;
				};


				/** chainable
				 *  BabelFish#setFallback(locale, fallbacks) -> BabelFish
				 *  - locale (String): Target locale
				 *  - fallbacks (Array): List of fallback locales
				 *
				 *  Set fallbacks for given locale.
				 *
				 *  When `locale` has no translation for the phrase, `fallbacks[0]` will be
				 *  tried, if translation still not found, then `fallbacks[1]` will be tried
				 *  and so on. If none of fallbacks have translation,
				 *  [[BabelFish#defaultLocale]] will be tried as last resort.
				 *
				 *  ##### Errors
				 *
				 *  - throws `Error`, when `locale` equals [[BabelFish#defaultLocale]]
				 *
				 *  ##### Example
				 *
				 *      i18n.setFallback('ua-UK', ['ua', 'ru']);
				 **/
				BabelFish.prototype.setFallback = function setFallback(locale, fallbacks) {
				  var self = this;

				  if (self.defaultLocale === locale) {
				    throw new Error("Default locale can't have fallbacks");
				  }

				  // clear out current fallbacks
				  if (!!self._fallbacks[locale]) {
				    forEach(self._fallbacks[locale], function (fallback) {
				      var idx = self._fallbacksReverse[fallback].indexOf(locale);
				      if (-1 !== idx) {
				        delete self._fallbacksReverse[fallback][idx];
				      }
				    });
				  }

				  // set new empty stack of fallbacks
				  self._fallbacks[locale] = [];

				  // fill in new fallbacks. defaultLocale is appended as last fallback
				  forEach(fallbacks, function (fallback) {
				    if (!self._fallbacksReverse[fallback]) {
				      self._fallbacksReverse[fallback] = [];
				    }

				    if (-1 === self._fallbacksReverse[fallback].indexOf(locale)) {
				      self._fallbacksReverse[fallback].push(locale);
				    }

				    self._fallbacks[locale].push(fallback);
				  });

				  // mark locale for recompilation
				  self._compiled[locale] = false;

				  return this;
				};


				/**
				 *  BabelFish#translate(locale, phrase[, params]) -> String
				 *  - locale (String): Locale of translation
				 *  - phrase (String): Phrase ID, e.g. `app.forums.replies_count`
				 *  - params (Object): Params for translation
				 *
				 *  ##### Example
				 *
				 *      i18n.addPhrase('ru-RU',
				 *        'apps.forums.replies_count',
				 *        '#{count} %{ответ|ответа|ответов}:count в теме');
				 *
				 *      // ...
				 *
				 *      i18n.translate('ru-RU', 'app.forums.replies_count', {count: 1});
				 *      // -> '1 ответ'
				 *
				 *      i18n.translate('ru-RU', 'app.forums.replies_count', {count: 2});
				 *      // -> '2 ответa'
				 **/
				BabelFish.prototype.translate = function translate(locale, phrase, params) {
				  var translator  = this.getCompiledData(locale, phrase);

				  if ('string' === translator.type) {
				    return String(translator.translation);
				  }

				  if ('function' === translator.type) {
				    return translator.translation.call({
				      flattenParams: flattenParams,
				      pluralize: Pluralizer
				    }, params);
				  }

				  return locale + ': No translation for [' + phrase + ']';
				};


				/**
				 *  BabelFish#hasPhrase(locale, phrase) -> Boolean
				 *  - locale (String): Locale of translation
				 *  - phrase (String): Phrase ID, e.g. `app.forums.replies_count`
				 *
				 *  Returns whenever or not there's a translation of a `phrase`.
				 **/
				BabelFish.prototype.hasPhrase = function hasPhrase(locale, phrase) {
				  var translator  = this.getCompiledData(locale, phrase);
				  return 'string' === translator.type || 'function' === translator.type;
				};


				/** alias of: BabelFish#translate
				 *  BabelFish#t(locale, phrase[, params]) -> String
				 **/
				BabelFish.prototype.t = BabelFish.prototype.translate;


				/**
				 *  BabelFish#getCompiledData(locale, phrase) -> Object
				 *  BabelFish#getCompiledData(locale) -> Object
				 *  - locale (String): Locale of translation
				 *  - phrase (String): Phrase ID, e.g. `app.forums.replies_count`
				 *
				 *  Returns compiled "translator", or object with compiled translators for all
				 *  phrases of `locale` if `phrase` was not specified.
				 *
				 *  Each translator is an object with fields:
				 *
				 *  - **type** _(String)_
				 *    - _string_:     Simple translation (contains no substitutions)
				 *    - _function_:   Translation with macroses
				 *
				 *  - **locale** _(String|Null)_
				 *    Locale of translation. It can differ from requested locale in case when
				 *    translation was taken from fallback locale.
				 *
				 *  - **translation** _(String|Function)_
				 **/
				BabelFish.prototype.getCompiledData = function getCompiledData(locale, phrase) {
				  var storage;

				  if (!locale) {
				    throw new Error('You must specify locale');
				  }

				  // force recompilation if needed
				  if (!this._compiled[locale]) {
				    recompile(this, locale);
				    this._compiled[locale] = true;
				  }

				  storage = getLocaleStorage(this, locale);

				  // requested FULL storage
				  if (!phrase) {
				    return storage;
				  }

				  return storage[phrase] || {};
				};


				// export module
				module.exports = BabelFish;
			}
		}
	}
})("babelfish/lib/babelfish");
